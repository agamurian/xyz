var D=Object.defineProperty,I=Object.defineProperties;var H=Object.getOwnPropertyDescriptors;var T=Object.getOwnPropertySymbols;var F=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable;var z=(i,t,s)=>t in i?D(i,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[t]=s,l=(i,t)=>{for(var s in t||(t={}))F.call(t,s)&&z(i,s,t[s]);if(T)for(var s of T(t))K.call(t,s)&&z(i,s,t[s]);return i},d=(i,t)=>I(i,H(t));var L=(i,t)=>{var s={};for(var e in i)F.call(i,e)&&t.indexOf(e)<0&&(s[e]=i[e]);if(i!=null&&T)for(var e of T(i))t.indexOf(e)<0&&K.call(i,e)&&(s[e]=i[e]);return s};import{derived as b,get as o,writable as m}from"svelte/store";var C=({parser:i,key:t,params:s,translations:e,locale:r,fallbackLocale:a})=>{if(!(t&&r))return console.warn("[i18n]: No translation key or locale provided. Skipping translation..."),"";let n=(e[r]||{})[t];return a&&n===void 0&&(n=(e[a]||{})[t]),i.parse(n,s,r,t)},h=(...i)=>i.length?i.filter(t=>!!t).map(t=>{let s=`${t}`.toLowerCase();try{let[e]=Intl.Collator.supportedLocalesOf(t);if(!e)throw new Error(`[i18n]: '${t}' is non-standard.`);s=e}catch{console.warn(`[i18n]: Non-standard locale provided: '${t}'. Check your 'translations' and 'loaders' in i18n config...`)}return s}):[],P=(i,t)=>Object.keys(i||{}).reduce((s,e)=>{let r=i[e],a=t?`${t}.${e}`:`${e}`;return r&&typeof r=="object"?l(l({},s),P(r,a)):d(l({},s),{[a]:r})},{}),j=async i=>{try{return(await Promise.all(i.map(r=>{var a=r,{loader:s}=a,e=L(a,["loader"]);return new Promise(async n=>{let c;try{c=await s()}catch(v){console.error(`[i18n]: Failed to load translation. Verify your '${e.locale}' > '${e.key}' Loader.`),console.error(v)}n(d(l({loader:s},e),{data:c}))})}))).reduce((s,{key:e,data:r,locale:a})=>{if(!r)return s;let[n]=h(a);return d(l({},s),{[n]:P(d(l({},s[n]||{}),{[e]:r}))})},{})}catch(t){console.error(t)}return{}},k=i=>t=>{try{if(typeof t=="string")return t===i;if(typeof t=="object")return t.test(i)}catch{throw new Error("[i18n]: Invalid route config!")}return!1},N=(i,t)=>{let s=!0;try{s=Object.keys(i).filter(e=>i[e]!==void 0).every(e=>i[e]===t[e])}catch{}return s};var A=1e3*60*60*24,E=class{constructor(t){this.cachedAt=0;this.loadedKeys={};this.currentRoute=m();this.config=m();this.isLoading=m(!1);this.promises=new Set;this.loading={subscribe:this.isLoading.subscribe,toPromise:(t,s)=>{let e=Array.from(this.promises).filter(r=>N({locale:h(t)[0],route:s},r)).map(({promise:r})=>r);return Promise.all(e)},get:()=>o(this.isLoading)};this.privateTranslations=m({});this.translations={subscribe:this.privateTranslations.subscribe,get:()=>o(this.translations)};this.locales=d(l({},b([this.config,this.privateTranslations],([t,s])=>{if(!t)return[];let{loaders:e=[]}=t,r=e.map(({locale:n})=>h(n)[0]),a=Object.keys(s).map(n=>h(n)[0]);return Array.from(new Set([...r,...a]))},[])),{get:()=>o(this.locales)});this.internalLocale=m();this.loaderTrigger=b([this.internalLocale,this.currentRoute],([t,s],e)=>{var r,a,n;t!==void 0&&s!==void 0&&(t!==((r=o(this.loaderTrigger))==null?void 0:r[0])||s!==((a=o(this.loaderTrigger))==null?void 0:a[1]))&&((n=o(this.config))!=null&&n.debug&&console.debug("[i18n]: Triggering translation load..."),e([t,s]))},[]);this.localeHelper=m();this.locale={subscribe:this.localeHelper.subscribe,forceSet:this.localeHelper.set,set:this.internalLocale.set,update:this.internalLocale.update,get:()=>o(this.locale)};this.initialized=b([this.locale,this.currentRoute,this.privateTranslations],([t,s,e],r)=>{o(this.initialized)||r(t!==void 0&&s!==void 0&&!!Object.keys(e).length)});this.translation=b([this.privateTranslations,this.locale,this.isLoading],([t,s,e],r)=>{let a=t[s];a&&Object.keys(a).length&&!e&&r(a)},{});this.t=d(l({},b([this.config,this.translation],([{parser:t,fallbackLocale:s}])=>(e,...r)=>C({parser:t,key:e,params:r,translations:this.translations.get(),locale:this.locale.get(),fallbackLocale:s}))),{get:(t,...s)=>o(this.t)(t,...s)});this.l=d(l({},b([this.config,this.translations],([{parser:t,fallbackLocale:s},e])=>(r,a,...n)=>C({parser:t,key:a,params:n,translations:e,locale:r,fallbackLocale:s}))),{get:(t,s,...e)=>o(this.l)(t,s,...e)});this.getLocale=t=>{if(!t)return"";let e=this.locales.get().find(r=>r===h(t)[0])||"";return h(e)[0]||""};this.setLocale=t=>{var e;if(!t)return;let[s]=h(t);if(s!==o(this.internalLocale))return(e=o(this.config))!=null&&e.debug&&console.debug(`[i18n]: Setting '${s}' locale.`),this.internalLocale.set(s),this.loading.toPromise(t,o(this.currentRoute))};this.setRoute=t=>{var s;if(t!==o(this.currentRoute)){(s=o(this.config))!=null&&s.debug&&console.debug(`[i18n]: Setting '${t}' route.`),this.currentRoute.set(t);let e=o(this.internalLocale);return this.loading.toPromise(e,t)}};this.loadConfig=async t=>{await this.configLoader(t)};this.getTranslationProps=async(t=this.locale.get(),s=o(this.currentRoute))=>{let e=o(this.config);if(!e||!t)return[];let r=this.translations.get(),{loaders:a,fallbackLocale:n="",cache:c=A}=e||{},v=Number.isNaN(+c)?A:+c;this.cachedAt?Date.now()>v+this.cachedAt&&(e!=null&&e.debug&&console.debug("[i18n]: Refreshing cache."),this.loadedKeys={},this.cachedAt=0):(e!=null&&e.debug&&console.debug("[i18n]: Setting cache timestamp."),this.cachedAt=Date.now());let[S,w]=h(t,n),O=r[S],W=r[w],x=(a||[]).map(R=>{var u=R,{locale:g}=u,f=L(u,["locale"]);return d(l({},f),{locale:h(g)[0]})}).filter(({routes:g})=>!g||(g||[]).some(k(s))).filter(({key:g,locale:f})=>f===S&&(!O||!(this.loadedKeys[S]||[]).includes(g))||n&&f===w&&(!W||!(this.loadedKeys[w]||[]).includes(g)));if(x.length){this.isLoading.set(!0),e!=null&&e.debug&&console.debug("[i18n]: Fetching translations...");let g=await j(x);this.isLoading.set(!1);let f=Object.keys(g).reduce((u,p)=>d(l({},u),{[p]:Object.keys(g[p])}),{}),R=x.filter(({key:u,locale:p})=>(f[p]||[]).some(y=>`${y}`.startsWith(u))).reduce((u,{key:p,locale:y})=>d(l({},u),{[y]:[...u[y]||[],p]}),{});return[g,R]}return[]};this.addTranslations=(t,s)=>{var r;if(!t)return;(r=o(this.config))!=null&&r.debug&&console.debug("[i18n]: Adding translations...");let e=Object.keys(t||{});this.privateTranslations.update(a=>e.reduce((n,c)=>d(l({},n),{[c]:l(l({},n[c]||{}),P(t[c]))}),a)),e.forEach(a=>{let n=Object.keys(t[a]).map(c=>`${c}`.split(".")[0]);s&&(n=s[a]),this.loadedKeys[a]=Array.from(new Set([...this.loadedKeys[a]||[],...n||[]]))})};this.loader=async([t,s])=>{var r;(r=o(this.config))!=null&&r.debug&&console.debug("[i18n]: Adding loader promise.");let e=(async()=>{let a=await this.getTranslationProps(t,s);a.length&&this.addTranslations(...a)})();this.promises.add({locale:t,route:s,promise:e}),e.then(()=>{let a=this.getLocale(t);a&&this.locale.get()!==a&&this.locale.forceSet(a)})};this.loadTranslations=(t,s=o(this.currentRoute)||"")=>{if(!!t)return this.setRoute(s),this.setLocale(t),this.loading.toPromise(t,s)};t&&this.loadConfig(t),this.loaderTrigger.subscribe(this.loader),this.isLoading.subscribe(async s=>{var e;s&&this.promises.size&&(await this.loading.toPromise(),this.promises.clear(),(e=o(this.config))!=null&&e.debug&&console.debug("[i18n]: Loader promises have been purged."))})}async configLoader(t){if(!t)throw new Error("[i18n]: No config provided!");let c=t,{initLocale:s,fallbackLocale:e,translations:r,debug:a}=c,n=L(c,["initLocale","fallbackLocale","translations","debug"]);[s]=h(s),[e]=h(e),a&&console.debug("[i18n]: Setting config."),this.config.set(l({initLocale:s,fallbackLocale:e,translations:r,debug:a},n)),r&&this.addTranslations(r),await this.loadTranslations(s)}};export{E as default};
